# ü™ü **Window Functions in SQL Server ‚Äî The Concept**

> üëâ A **window function** performs a calculation across a set of rows that are somehow related to the current row, **but without collapsing rows**.

It gives you a _‚Äúwindow of vision‚Äù_ to look at other rows while still keeping your current row intact.

---

## ‚ÅâÔ∏è **The Problem: Why Do We Need Them?**

Imagine you have a table:

| EmployeeID | Name  | Dept | Salary |
| ---------- | ----- | ---- | ------ |
| 1          | Alice | IT   | 6000   |
| 2          | Bob   | IT   | 5000   |
| 3          | Carol | HR   | 4000   |
| 4          | Dave  | HR   | 4500   |
| 5          | Eve   | IT   | 7000   |

üí≠ **Common Questions:**

- "Show each employee and their department‚Äôs average salary."
- "Rank employees by salary within their department."
- "Calculate cumulative salary spending over time."

üëâ **let us solve this:**  
"Show each employee and their department‚Äôs average salary."

### **1. ‚ùå Wrong Answer** (just `GROUP BY`)

```sql
SELECT Dept, AVG(Salary)
FROM Employees
GROUP BY Dept;
```

‚ùå Problem ‚Üí You lose the individual employee rows. You only get aggregates.

---

### **2. ‚úÖ Without window functions** using **subqueries or joins**

```sql
SELECT
    e.Name,
    e.Dept,
    e.Salary,
    d.AvgDeptSalary
FROM Employees e
JOIN (
    SELECT Dept, AVG(Salary) AS AvgDeptSalary
    FROM Employees
    GROUP BY Dept
) d
ON e.Dept = d.Dept;
```

‚ùå Problems:

- Extra joins / subqueries everywhere
- Hard to read, hard to maintain
- Performance hit when repeated in many places

### **3. ‚úÖ Using Window functions**

```sql
SELECT
    Name,
    Dept,
    Salary,
    AVG(Salary) OVER (PARTITION BY Dept) AS AvgDeptSalary
FROM Employees;
```

‚úÖ Much cleaner, easier to extend.

---

## üèõÔ∏è **Anatomy**

```sql
function_name (expression)
OVER (
    [PARTITION BY column_list]  -- optional
    [ORDER BY column_list]      -- optional
)
```

1. **function_name** ‚Üí
   - Aggregate (`SUM`, `AVG`, `MIN`, `MAX`),
   - Ranking (`ROW_NUMBER`, `RANK`, `DENSE_RANK`), or
   - Offset (`LAG`, `LEAD`)
2. **PARTITION BY** ‚Üí
   - groups of rows (like GROUP BY, but non-destructive)
3. **ORDER BY** ‚Üí
   - defines order (needed for ranking and running aggregates)

---

## üê™ **Behaviors of Window Functions**

### 1Ô∏è‚É£ **Distributed Aggregation** (Partition Snapshot)

üëâ Behavior: Compute once per group, paste on every row.
Equivalent to ‚ÄúGROUP BY + Join‚Äù, but inline.

```sql
SELECT
    Name,
    Dept,
    Salary,
    AVG(Salary) OVER (PARTITION BY Dept) AS AvgDeptSalary
FROM Employees;
```

**Input:**

| Name  | Dept | Salary |
| ----- | ---- | ------ |
| Alice | IT   | 6000   |
| Bob   | IT   | 5000   |
| Eve   | IT   | 7000   |
| Carol | HR   | 4000   |
| Dave  | HR   | 4500   |

**Output:**

| Name  | Dept | Salary | AvgDeptSalary |
| ----- | ---- | ------ | ------------- |
| Alice | IT   | 6000   | 6000          |
| Bob   | IT   | 5000   | 6000          |
| Eve   | IT   | 7000   | 6000          |
| Carol | HR   | 4000   | 4250          |
| Dave  | HR   | 4500   | 4250          |

‚úÖ Each row shows the **group‚Äôs aggregate**, but rows are preserved.

---

### 2Ô∏è‚É£ **Running Aggregation** (Sequential / Ordered)

üëâ Behavior: Works row by row in an order, producing incremental calculations.
Equivalent to writing a **correlated subquery with ORDER BY**, but much faster.

```sql
SELECT
    EmpID,
    HireDate,
    Salary,
    SUM(Salary) OVER (ORDER BY HireDate) AS RunningTotal
FROM Employees;
```

**Input (ordered by HireDate):**

| EmpID | HireDate   | Salary |
| ----- | ---------- | ------ |
| 1     | 2020-01-01 | 4000   |
| 2     | 2020-03-01 | 4500   |
| 3     | 2020-04-01 | 5000   |

**Output:**

| EmpID | HireDate   | Salary | RunningTotal |
| ----- | ---------- | ------ | ------------ |
| 1     | 2020-01-01 | 4000   | 4000         |
| 2     | 2020-03-01 | 4500   | 8500         |
| 3     | 2020-04-01 | 5000   | 13500        |

‚úÖ Each row builds on the previous ones, cumulative style.

---

### 3Ô∏è‚É£ **Running Aggregation per Partition** (Position Within Order)

üëâ Behavior: Assigns numbers to rows based on order (and partition if used).

```sql
SELECT
    Name,
    Dept,
    Salary,
    RANK() OVER (PARTITION BY Dept ORDER BY Salary DESC) AS DeptRank
FROM Employees;
```

**Output:**

| Name  | Dept | Salary | DeptRank |
| ----- | ---- | ------ | -------- |
| Eve   | IT   | 7000   | 1        |
| Alice | IT   | 6000   | 2        |
| Bob   | IT   | 5000   | 3        |
| Dave  | HR   | 4500   | 1        |
| Carol | HR   | 4000   | 2        |

‚úÖ Row-by-row ‚Äúpositioning‚Äù inside the partition.

---

## ‚öñÔ∏è **Comparison**

| Task                    | Without Window Functions | With Window Functions            |
| ----------------------- | ------------------------ | -------------------------------- |
| Dept avg per employee   | Subquery + join          | `AVG() OVER (PARTITION BY Dept)` |
| Running totals          | Correlated subquery      | `SUM() OVER (ORDER BY ‚Ä¶)`        |
| Row numbers             | Temp table + IDENTITY    | `ROW_NUMBER() OVER (ORDER BY ‚Ä¶)` |
| Previous/next row value | Self join                | `LAG()` / `LEAD()`               |

---

## üèÅ **Key Takeaways**

- **GROUP BY collapses**, **Window functions preserve rows**.
- **Distributed behavior** = group snapshot values per row.
- **Running behavior** = sequential accumulation per row.
- **Ranking** = ordered row numbering or rank assignment.
- They **replace messy subqueries and joins** with clean, inline calculations.
