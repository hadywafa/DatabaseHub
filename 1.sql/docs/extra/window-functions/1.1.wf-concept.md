# ü™ü **Window Functions in SQL Server ‚Äî The Concept**

> üëâ A **window function** performs a calculation across a set of rows that are somehow related to the current row, **but without collapsing rows**.

It gives you a _‚Äúwindow of vision‚Äù_ to look at other rows while still keeping your current row intact.

---

## ‚ÅâÔ∏è **The Problem: Why Do We Need Them?**

Imagine you have a table:

| EmployeeID | Name  | Dept | Salary |
| ---------- | ----- | ---- | ------ |
| 1          | Alice | IT   | 6000   |
| 2          | Bob   | IT   | 5000   |
| 3          | Carol | HR   | 4000   |
| 4          | Dave  | HR   | 4500   |
| 5          | Eve   | IT   | 7000   |

üí≠ **Common Questions:**

- "Show each employee and their department‚Äôs average salary."
- "Rank employees by salary within their department."
- "Calculate cumulative salary spending over time."

üëâ **let us solve this:**  
"Show each employee and their department‚Äôs average salary."

### **1. ‚ùå Wrong Answer** (just `GROUP BY`)

```sql
SELECT Dept, AVG(Salary)
FROM Employees
GROUP BY Dept;
```

‚ùå Problem ‚Üí You lose the individual employee rows. You only get aggregates.

---

### **2. ‚úÖ Without window functions** using **subqueries or joins**

```sql
SELECT
    e.Name,
    e.Dept,
    e.Salary,
    d.AvgDeptSalary
FROM Employees e
JOIN (
    SELECT Dept, AVG(Salary) AS AvgDeptSalary
    FROM Employees
    GROUP BY Dept
) d
ON e.Dept = d.Dept;
```

‚ùå Problems:

- Extra joins / subqueries everywhere
- Hard to read, hard to maintain
- Performance hit when repeated in many places

### **3. ‚úÖ Using Window functions**

```sql
SELECT
    Name,
    Dept,
    Salary,
    AVG(Salary) OVER (PARTITION BY Dept) AS AvgDeptSalary
FROM Employees;
```

‚úÖ Much cleaner, easier to extend.

---

## üèõÔ∏è **Anatomy**

```sql
function_name (expression)
OVER (
    [PARTITION BY column_list]  -- optional
    [ORDER BY column_list]      -- optional
)
```

1. **function_name** ‚Üí
   - Aggregate (`SUM`, `AVG`, `MIN`, `MAX`),
   - Ranking (`ROW_NUMBER`, `RANK`, `DENSE_RANK`), or
   - Offset (`LAG`, `LEAD`)
2. **PARTITION BY** ‚Üí
   - groups of rows (like GROUP BY, but non-destructive)
3. **ORDER BY** ‚Üí
   - defines order (needed for ranking and running aggregates)

---

## üê™ **Behaviors of Window Functions**

### 1Ô∏è‚É£ **Distributed Aggregation** (Partition Snapshot)

üëâ Behavior: Compute once per group, paste on every row.
Equivalent to ‚ÄúGROUP BY + Join‚Äù, but inline.

```sql
SELECT
    Name,
    Dept,
    Salary,
    AVG(Salary) OVER (PARTITION BY Dept) AS AvgDeptSalary
FROM Employees;
```

**1.Input:**

| Name  | Dept | Salary |
| ----- | ---- | ------ |
| Alice | IT   | 6000   |
| Bob   | IT   | 5000   |
| Carol | HR   | 4000   |
| Eve   | IT   | 7000   |
| Dave  | HR   | 4500   |

**2.Partitioning:**

- IT Dept: {6000, 5000, 7000} ‚Üí average = (6000 + 5000 + 7000) √∑ 3 = 6000
- HR Dept: {4000, 4500} ‚Üí average = (4000 + 4500) √∑ 2 = 4250

**3.Output:**

| Name  | Dept | Salary | AvgDeptSalary |
| ----- | ---- | ------ | ------------- |
| Alice | IT   | 6000   | 6000          |
| Bob   | IT   | 5000   | 6000          |
| Carol | HR   | 4000   | 4250          |
| Eve   | IT   | 7000   | 6000          |
| Dave  | HR   | 4500   | 4250          |

‚úÖ Each row shows the **group‚Äôs aggregate**, but rows are preserved.

---

### 2Ô∏è‚É£ **Running Aggregation** (Sequential / Ordered)

üëâ Behavior: Works row by row in an order, producing incremental calculations.
Equivalent to writing a **correlated subquery with ORDER BY**, but much faster.

```sql
SELECT
    EmpID,
    HireDate,
    Salary,
    SUM(Salary) OVER (ORDER BY HireDate) AS RunningTotal
FROM Employees;
```

**1.Input (ordered by HireDate):**

| EmpID | HireDate   | Salary |
| ----- | ---------- | ------ |
| 3     | 2020-04-01 | 5000   |
| 2     | 2020-03-01 | 4500   |
| 1     | 2020-01-01 | 4000   |

**2.Ordering:**

SQL will re-order by `HireDate` first:

| EmpID | HireDate   | Salary |
| ----- | ---------- | ------ |
| 1     | 2020-01-01 | 4000   |
| 2     | 2020-03-01 | 4500   |
| 3     | 2020-04-01 | 5000   |

Now it computes the running total:

**3.Window Function Execution as Sequential:**

- Row 1 ‚Üí 4000
- Row 2 ‚Üí 4000 + 4500 = 8500
- Row 3 ‚Üí 8500 + 5000 = 13,500

**3.Final Output (with correct running total):**

| EmpID | HireDate   | Salary | RunningTotal |
| ----- | ---------- | ------ | ------------ |
| 1     | 2020-01-01 | 4000   | 4000         |
| 2     | 2020-03-01 | 4500   | 8500         |
| 3     | 2020-04-01 | 5000   | 13,500       |

> ‚úÖ **Conclusion:**  
> Even if the input rows are out of order, the `ORDER BY` inside `OVER()` ensures the running sum is calculated in the correct chronological order.
> Each row builds on the previous ones, cumulative style.

---

### 3Ô∏è‚É£ **Running Aggregation per Partition** (Position Within Order)

üëâ Behavior: Assigns numbers to rows based on order (and partition if used).

Here‚Äôs your query:

```sql
SELECT
    Name,
    Dept,
    Salary,
    RANK() OVER (PARTITION BY Dept ORDER BY Salary DESC) AS DeptRank
FROM Employees;
```

---

**üîé Step-by-step:**

- `PARTITION BY Dept` ‚Üí break rows into groups by department.
- `ORDER BY Salary DESC` ‚Üí sort each department from highest salary to lowest.
- `RANK()` ‚Üí assign rank **starting at 1**, but with _ties allowed_ (same salary ‚Üí same rank, and the next rank is skipped).

---

**1.Input:**

| Name  | Dept | Salary |
| ----- | ---- | ------ |
| Alice | IT   | 6000   |
| Bob   | IT   | 5000   |
| Eve   | IT   | 7000   |
| Carol | HR   | 4000   |
| Dave  | HR   | 4500   |

---

**2.Partitioning:**

- **IT Dept (ordered by Salary DESC):** Eve (7000), Alice (6000), Bob (5000)
- **HR Dept (ordered by Salary DESC):** Dave (4500), Carol (4000)

**3.Window Function Execution:**

- **IT Dept (ordered by Salary DESC):** Eve (1), Alice (2), Bob (3)
- **HR Dept (ordered by Salary DESC):** Dave (1), Carol (2)

---

**Output:**

| Name  | Dept | Salary | DeptRank |
| ----- | ---- | ------ | -------- |
| Eve   | IT   | 7000   | 1        |
| Alice | IT   | 6000   | 2        |
| Bob   | IT   | 5000   | 3        |
| Dave  | HR   | 4500   | 1        |
| Carol | HR   | 4000   | 2        |

‚úÖ **Key Notes:**

- `RANK()` gives **ties the same rank**, but **leaves gaps** after ties.

  - e.g. If two IT employees had salary = 7000, both would be rank **1**, and the next one would be rank **3** (skipping 2).

- Variations:

  - `DENSE_RANK()` ‚Üí no gaps (after tie rank 1, next would be rank 2).
  - `ROW_NUMBER()` ‚Üí always unique, breaks ties arbitrarily (based on order).

---

## ‚öñÔ∏è **Comparison**

| Task                    | Without Window Functions | With Window Functions            |
| ----------------------- | ------------------------ | -------------------------------- |
| Dept avg per employee   | Subquery + join          | `AVG() OVER (PARTITION BY Dept)` |
| Running totals          | Correlated subquery      | `SUM() OVER (ORDER BY ‚Ä¶)`        |
| Row numbers             | Temp table + IDENTITY    | `ROW_NUMBER() OVER (ORDER BY ‚Ä¶)` |
| Previous/next row value | Self join                | `LAG()` / `LEAD()`               |

---

## üèÅ **Key Takeaways**

- **GROUP BY collapses**, **Window functions preserve rows**.
- **Distributed behavior** = group snapshot values per row.
- **Running behavior** = sequential accumulation per row.
- **Ranking** = ordered row numbering or rank assignment.
- They **replace messy subqueries and joins** with clean, inline calculations.
