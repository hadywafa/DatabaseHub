# üîé **Index Seek vs. Index Scan vs. Table Scan**

Indexes help databases **retrieve data efficiently**, but how they are used‚Äîvia **Index Seek, Index Scan, or Table Scan**‚Äîgreatly impacts **query performance**.

**‚úÖ Index Seek:**

‚úî **Uses B-Tree traversal** to quickly find **only necessary data pages**.  
‚úî **Highly efficient for selective queries**.

**‚ö†Ô∏è Index Scan:**

‚úî **Reads all index entries sequentially**, then retrieves **all matching data pages**.  
‚úî **Better than Table Scan but still slower than Index Seek**.

**‚ùå Table Scan:**

‚úî **Reads every row in the table** without using an index.  
‚úî **Slowest option, causing high disk I/O and memory usage**.

> Table scan means iterate over all table rows.
> Index scan means iterate over all index items, when item index meets search condition, table row is retrived through index.
> Usually index scan is less expensive than a table scan because index is more flat than a table.

---

## **üìå How Indexes Store Data (B-Tree Structure)**

Indexes are **stored in structured pages** using a **B-Tree (Balanced Tree) structure**, with three levels:

| **Page Type**          | **Function**                                                      |
| ---------------------- | ----------------------------------------------------------------- |
| **Root Page**          | Entry point for searches, stores pointers to intermediate pages.  |
| **Intermediate Pages** | Store **pointers to leaf pages** for faster lookups.              |
| **Leaf Pages**         | Contain **Row IDs (RID)** or **actual data (Clustered Indexes).** |

‚úÖ **Index pages are separate from data pages**, allowing faster lookups.

---

## **üìå What is Index Seek?**

‚úî **Index Seek is a targeted search** that **navigates the B-Tree structure**, finds **only relevant rows**, and retrieves **only required data pages**.

### **Lifecycle of an Index Seek**

**1Ô∏è‚É£ Root Index Page is loaded into memory.**  
**2Ô∏è‚É£ B-Tree Traversal is performed to find the Leaf Page.**  
**3Ô∏è‚É£ Leaf Page contains the Row ID (RID).**  
**4Ô∏è‚É£ Only the necessary data page is fetched using the RID.**  
**5Ô∏è‚É£ Matching rows are returned.**

üîπ **Index Seek is optimal for queries retrieving a small number of rows.**

---

### **Example: How Index Seek Works**

‚úî **Scenario: Searching for `id = 1001` in an Index**

```sql
SELECT * FROM Employees WHERE id = 1001;
```

| **Index Level**                 | **Page Content**                                             |
| ------------------------------- | ------------------------------------------------------------ |
| **Root Page**                   | Pointers to **Intermediate Pages**                           |
| **Intermediate Page 1**         | Pointers to **Leaf Pages (id: 1 - 1000, 1001 - 2000, etc.)** |
| **Leaf Page (id: 1001 - 2000)** | **Row ID (1001) ‚Üí Page 50**                                  |
| **Data Page 50**                | Full record: **(1001, Alice, 30, \$5000)**                   |

---

### **Index Seek Execution Process**

```mermaid
sequenceDiagram
    participant SQLClient as SQL Client (User Application) üíª
    participant QueryEngine as Query Execution Engine üîç
    participant RAM as RAM (Buffer Cache) üñ•Ô∏è
    participant Disk as Database Storage üíΩ

    Note over SQLClient: 1Ô∏è‚É£ User sends query request
    SQLClient->>QueryEngine: Execute `SELECT * FROM Employees WHERE id = 1001`

    Note over QueryEngine: 2Ô∏è‚É£ Query Execution Engine starts execution and checks cache
    QueryEngine->>RAM: Check if Index Pages are in Memory

    alt Index Pages Found in RAM
        Note over RAM: ‚úÖ No need to access disk
    else Index Pages Not Found
        QueryEngine->>Disk: Load **Root Index Page**
        Disk->>RAM: Store **Root Index Page**

        Note over RAM: 3Ô∏è‚É£ Root Page points to the correct Intermediate Page
        QueryEngine->>Disk: Load **Intermediate Index Page**
        Disk->>RAM: Store **Intermediate Index Page**

        Note over RAM: 4Ô∏è‚É£ Intermediate Page points to the correct Leaf Page
        QueryEngine->>Disk: Load **Leaf Index Page**
        Disk->>RAM: Store **Leaf Index Page**

        Note over RAM: 5Ô∏è‚É£ Leaf Page contains the Row ID (RID) of the required data row
    end

    QueryEngine->>Disk: Retrieve **Data Page using Row ID (RID 1001)**
    Disk->>RAM: Store **Data Page in Memory**

    Note over RAM: 6Ô∏è‚É£ Data Page is now in RAM and ready for processing
    RAM->>QueryEngine: Return **Employee Data (id = 1001, Alice, 30, $5000)**

    Note over QueryEngine: ‚úÖ Query Execution Engine processes the retrieved data
    QueryEngine->>SQLClient: Send Query Result (Employee Data)

    Note over SQLClient: 7Ô∏è‚É£ SQL Client receives and displays query results
```

‚úî **Only the necessary index and data pages are accessed.**  
‚úî **Efficient B-Tree search avoids reading unnecessary pages.**

---

## **üìå What is Index Scan?**

‚ùå **Index Scan reads all index pages sequentially, loads all matching data pages into memory, and then returns the result.**

### **Lifecycle of an Index Scan**

**1Ô∏è‚É£ All index pages are read sequentially** to find **Row IDs (RID)** that match the query condition.  
**2Ô∏è‚É£ Only the necessary data pages containing those Row IDs are loaded into memory.**  
**3Ô∏è‚É£ Matching rows are immediately returned to the query engine.**

üîπ **Unlike a Table Scan, an Index Scan does not read all data pages‚Äîit first finds Row IDs in the index before accessing data pages.**

---

### **Example: How Index Scan Works**

‚úî **Scenario: Searching for `age > 30`**

```sql
SELECT * FROM Employees WHERE age > 30;
```

| **Index Level** | **Page Content**                            |
| --------------- | ------------------------------------------- |
| **Root Page**   | Pointers to all rows.                       |
| **Leaf Pages**  | Contains **all employee records**.          |
| **Data Pages**  | All pages loaded into RAM before filtering. |

---

### **Index Scan Execution Process**

```mermaid
sequenceDiagram
    participant SQLClient as SQL Client üíª
    participant QueryEngine as Query Execution Engine üîç
    participant RAM as RAM (Buffer Cache) üñ•Ô∏è
    participant Disk as Database Storage üíΩ

    Note over SQLClient: 1Ô∏è‚É£ User sends query request
    SQLClient->>QueryEngine: Execute `SELECT * FROM Employees WHERE age > 30`

    Note over QueryEngine: 2Ô∏è‚É£ Query Engine loads all index pages
    QueryEngine->>RAM: Check if Index Pages are in Memory

    alt Index Pages Found in RAM
        Note over RAM: ‚úÖ No need to access disk
    else Index Pages Not Found
        QueryEngine->>Disk: Load **All Index Pages**
        Disk->>RAM: Store **All Index Pages in Memory**
    end

    Note over RAM: 3Ô∏è‚É£ Index Scan finds Row IDs (RID) for `age > 30`
    QueryEngine->>RAM: Retrieve **Row IDs (RID) from Leaf Index Pages**

    QueryEngine->>Disk: Load **Only the Data Pages containing these Row IDs**
    Disk->>RAM: Store **Only necessary Data Pages in Memory**

    RAM->>QueryEngine: 4Ô∏è‚É£ Matching rows are returned immediately
    QueryEngine->>SQLClient: Send Query Result
```

‚úî **Index Scan loads only the required data pages, unlike Table Scan.**

---

## **üìå What is Table Scan?**

‚ùå **Table Scan reads every row in the table because no index is used.**

### **Lifecycle of a Table Scan**

**1Ô∏è‚É£ All data pages for the table are read into memory.**  
**2Ô∏è‚É£ Filtering is applied row by row in memory.**  
**3Ô∏è‚É£ Matching rows are returned.**

üîπ **Table Scan is the slowest method and should be avoided.**

---

### **Table Scan Execution Process**

```mermaid
sequenceDiagram
    participant SQLClient as SQL Client üíª
    participant QueryEngine as Query Execution Engine üîç
    participant RAM as RAM (Buffer Cache) üñ•Ô∏è
    participant Disk as Database Storage üíΩ

    Note over SQLClient: 1Ô∏è‚É£ User sends query request
    SQLClient->>QueryEngine: Execute `SELECT * FROM Employees WHERE age > 30`

    Note over QueryEngine: 2Ô∏è‚É£ No Index Found! Query Engine performs a Full Table Scan
    QueryEngine->>Disk: Load **All Data Pages from Disk**
    Disk->>RAM: Store **All Data Pages in Memory**

    Note over RAM: 3Ô∏è‚É£ Apply filtering row by row in memory
    QueryEngine->>RAM: Scan every row **one by one**

    RAM->>QueryEngine: Return filtered rows
    QueryEngine->>SQLClient: Send Query Result
```

## **üöÄ Performance Comparison: Index Seek vs. Index Scan vs. Table Scan**

| **Feature**      | **Index Seek ‚úÖ**               | **Index Scan ‚ö†Ô∏è**                        | **Table Scan ‚ùå**                |
| ---------------- | ------------------------------- | ---------------------------------------- | -------------------------------- |
| **Data Access**  | **B-Tree Traversal**            | **Reads all index rows**                 | **Reads all table rows**         |
| **Performance**  | ‚úÖ **Fastest (Selective Read)** | ‚ö†Ô∏è **Moderate (Index Read + Data Read)** | ‚ùå **Slowest (Full Table Read)** |
| **I/O Overhead** | ‚úÖ **Low**                      | ‚ö†Ô∏è **Medium**                            | ‚ùå **High**                      |
| **CPU Cost**     | ‚úÖ **Low**                      | ‚ö†Ô∏è **Moderate**                          | ‚ùå **Very High**                 |
