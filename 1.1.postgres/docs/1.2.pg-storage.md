# ğŸ“‚ **How PostgreSQL Stores Data on the File System (Pages, Blocks, and Storage Layout)**

PostgreSQL stores data in **a structured file system format**, organizing tables and indexes into **blocks, pages, and segments**. Understanding this helps with **performance tuning, storage optimization, and troubleshooting**.

---

## ğŸ” **1. Overview: PostgreSQL Storage System**

PostgreSQL follows a **multi-layered storage structure**, where:

- âœ”ï¸ Data is **stored in files** inside the **PostgreSQL data directory**.
- âœ”ï¸ Each **table and index** is broken into **1GB segment files** for efficiency.
- âœ”ï¸ Data is stored in **8KB pages** (blocks), which contain **rows (tuples)**.
- âœ”ï¸ PostgreSQL **never overwrites old rows** but marks them as **dead tuples** (handled by VACUUM).

---

## ğŸ“‚ **2. Tablespaces, Data Files & Directory Structure**

### ğŸ”¹ **Default Storage Location**

By default, PostgreSQL stores all data in:  
ğŸ“ **`$PGDATA/base/`**

Each database inside PostgreSQL is stored as a **separate directory**, named by its **database OID**.

```bash
ls -lh /var/lib/postgresql/15/main/base/
```

ğŸ“Œ **Example Output:**

```ini
12345/  67890/  54321/
```

- `12345/` â†’ Directory for one PostgreSQL database
- `67890/` â†’ Directory for another database

### ğŸ”¹ **Tablespace Layout**

| Tablespace            | Directory Location                       |
| --------------------- | ---------------------------------------- |
| **pg_default**        | `$PGDATA/base/` (default storage)        |
| **pg_global**         | `$PGDATA/global/` (shared system tables) |
| **Custom Tablespace** | Stored in a user-specified directory     |

ğŸ“Œ **Query to List Tablespaces**

```sql
SELECT spcname, spclocation FROM pg_tablespace;
```

---

## ğŸ“ **3. Storage Layout: Segments, Blocks, and Pages**

### ğŸ”¹ **Storage Hierarchy in PostgreSQL**

ğŸ“‚ **Database Directory** â†’ ğŸ“„ **Relation Files (1GB Segments)** â†’ ğŸ“¦ **Blocks (8KB Pages)** â†’ ğŸ”¹ **Tuples (Rows)**

### ğŸ”„ **File Naming Format in PostgreSQL**

Each table or index consists of **multiple segment files** in this format:

```ini
<relfilenode>.1
<relfilenode>.2
```

ğŸ“Œ **Example: Table `users` with ID `16384`**

```bash
ls -lh /var/lib/postgresql/15/main/base/12345/
16384
16384.1
16384.2
16384_fsm
16384_vm
```

| File Type     | Description                             |
| ------------- | --------------------------------------- |
| **16384**     | First 1GB of the table                  |
| **16384.1**   | Second 1GB segment                      |
| **16384_fsm** | Free Space Map (tracks empty space)     |
| **16384_vm**  | Visibility Map (tracks vacuumed tuples) |

ğŸ”¹ **Why 1GB Segments?**  
PostgreSQL splits large tables into **1GB chunks** to avoid filesystem limitations.

---

## ğŸ“¦ **4. Heap Tables: Page Format & Row Storage**

Each **table and index** in PostgreSQL is stored as **8KB pages** (also called blocks).

### **ğŸ”„ PostgreSQL Heap Page Format**

ğŸ“¦ **A single 8KB page contains:**

```ini
| Page Header | Free Space | Row 1 | Row 2 | Row 3 | ...
```

| Section                             | Description                                                                 |
| ----------------------------------- | --------------------------------------------------------------------------- |
| **Page Header (24 bytes)**          | Stores metadata like checksums, LSN (Log Sequence Number), and tuple count. |
| **Row Pointers (Item Identifiers)** | Pointers to actual row locations within the page.                           |
| **Heap Tuples (Row Data)**          | The actual table data (rows).                                               |
| **Free Space**                      | Empty space for future row inserts.                                         |

### **ğŸ”„ How PostgreSQL Inserts a Row?**

- **1ï¸âƒ£** The backend **fetches a page** from the table file.
- **2ï¸âƒ£** If enough **free space** exists, the row is inserted.
- **3ï¸âƒ£** If not, PostgreSQL **allocates a new page**.
- **4ï¸âƒ£** The rowâ€™s **transaction status** is marked for visibility.

ğŸ“Œ **Checking Page-Level Information**

```sql
SELECT * FROM heap_page_items(get_raw_page('users', 0));
```

---

## ğŸ—ï¸ **5. TOAST: Storing Large Values Efficiently**

**TOAST (The Oversized Attribute Storage Technique)** is PostgreSQLâ€™s way of storing **large text, JSON, or bytea columns** efficiently.

### ğŸ”¹ **Why TOAST Exists?**

Since a **single page is 8KB**, PostgreSQL **cannot store large values** directly inside a row. Instead, it:  
âœ… Moves large values **out of the main table** into a **TOAST table**.  
âœ… Keeps only a **pointer** in the original row.

### **ğŸ”„ TOAST Storage Workflow**

- **1ï¸âƒ£** A large text or JSON column **exceeds 8KB**.
- **2ï¸âƒ£** PostgreSQL **moves the data to a separate TOAST table**.
- **3ï¸âƒ£** The row now stores only a **reference (OID) to the TOAST table**.
- **4ï¸âƒ£** When queried, PostgreSQL **fetches the large value from TOAST**.

ğŸ“Œ **Checking TOAST Tables**

```sql
SELECT relname, reltoastrelid FROM pg_class WHERE relname = 'users';
```

---

## ğŸ“‘ **6. Indexes: How PostgreSQL Indexes Are Stored**

PostgreSQL supports different index types (**B-Tree, Hash, GiST, GIN, BRIN**), and each has its **own file format**.

### **ğŸ”¹ B-Tree Index Storage**

âœ… Stored in **8KB pages**.  
âœ… Uses a **balanced tree** for fast lookups.  
âœ… Leaf nodes store **pointers to table rows**.

ğŸ“Œ **Checking Index File Size**

```sql
SELECT pg_relation_size('users_index');
```

ğŸ“Œ **Viewing Index Structure**

```sql
EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM users WHERE email = 'test@example.com';
```

---

## ğŸ›  **7. Vacuum & Storage Maintenance**

### **ğŸ”¹ Why Does PostgreSQL Need VACUUM?**

âœ… **PostgreSQL never updates rows in place.**  
âœ… Old rows remain **until VACUUM reclaims space**.  
âœ… The **Visibility Map** helps track vacuumed pages.

ğŸ“Œ **Running Vacuum Manually**

```sql
VACUUM ANALYZE users;
```

ğŸ“Œ **Checking Dead Tuples**

```sql
SELECT relname, n_dead_tup FROM pg_stat_user_tables WHERE relname = 'users';
```

---

## ğŸ¯ **Final Takeaways**

âœ”ï¸ **PostgreSQL stores data in 8KB pages** for efficient access.  
âœ”ï¸ **Tables and indexes split into 1GB segment files.**  
âœ”ï¸ **TOAST stores large values separately to save space.**  
âœ”ï¸ **Vacuum is necessary to reclaim space from dead tuples.**  
âœ”ï¸ **Indexes are stored as B-Trees for fast lookups.**
