# ğŸ“Œ **Deep Dive into Indexing in DocumentDB (MongoDB) â€“ How It Works Internally ğŸš€**

Indexing is **one of the most important** optimization techniques in **MongoDB (AWS DocumentDB)**. Without indexes, MongoDB must **scan every document in a collection** to find the matching results, which **is slow and inefficient**.

---

## ğŸ› ï¸ **1ï¸âƒ£ What is Indexing & Why It Matters?**

An **index** is a **special data structure** that **stores a mapping** between a fieldâ€™s values and the locations of corresponding documents.

âœ… **Indexing improves query speed** by reducing the number of documents that MongoDB needs to scan.  
âœ… **Without an index, MongoDB performs a full collection scan** (equivalent to SQL Table Scan).  
âœ… **With an index, MongoDB performs an Index Seek or Index Scan** (like SQL Index Seek).

ğŸ“Œ **Example Without an Index:**

```json
db.users.findOne({ "email": "ahmed@example.com" })
```

ğŸš¨ **Slow Query!** MongoDB must **scan every document** in the collection to find the match.

ğŸ“Œ **Example With an Index:**

```json
db.users.createIndex({ "email": 1 })
db.users.findOne({ "email": "ahmed@example.com" })
```

âœ… **Faster Query!** The index allows MongoDB to **jump directly to the matching document** instead of scanning all documents.

---

## ğŸ—ï¸ **2ï¸âƒ£ Types of Indexes in DocumentDB**

MongoDB supports **several types of indexes**, each optimized for different query patterns.

### **1ï¸âƒ£ Single-Field Index**

- Indexes a **single field** for **fast lookups**.
- **Example:** Index on `email`

```json
db.users.createIndex({ "email": 1 })
```

âœ… **Best for:** Lookups on a single field (`db.users.findOne({ "email": "ahmed@example.com" })`).

---

### **2ï¸âƒ£ Compound Index**

- Indexes **multiple fields together**.
- **Example:** Index on `name` and `age`

```json
db.users.createIndex({ "name": 1, "age": -1 })
```

âœ… **Best for:** Queries that filter on **both `name` and `age`** together.

ğŸ“Œ **Important:** **Order matters!** The query must use the fields in the same **left-to-right order** for best performance.

---

### **3ï¸âƒ£ Multi-Key Index**

- **Indexes arrays** (when a field contains an array).
- **Example:** Index on `tags` (an array field)

```json
db.posts.createIndex({ "tags": 1 })
```

> âœ”ï¸ **Best for:** Queries searching inside arrays (`db.posts.find({ "tags": "mongodb" })`).
>
> ğŸš¨ **Note:** **Multi-key indexes canâ€™t be used for sorting** when combined with another field.

---

### **4ï¸âƒ£ Text Index**

- **Used for full-text search** (searching words inside text fields).
- **Example:**

```json
db.articles.createIndex({ "content": "text" })
```

> âœ”ï¸ **Best for:** Searching blog posts, comments, or product descriptions.

```json
db.articles.find({ "$text": { "$search": "database indexing" } })
```

> ğŸš¨ **Note:** **Text indexes donâ€™t support sorting** (you canâ€™t combine full-text search with sorting efficiently).

---

### **5ï¸âƒ£ Hashed Index**

- **Uses a hash function** instead of storing values in sorted order.
- **Example:** Index on `_id`

```json
db.users.createIndex({ "_id": "hashed" })
```

> âœ”ï¸ **Best for:** **Sharding (evenly distributing data)** across multiple servers.
>
> ğŸš¨ **Note:** **Hashed indexes donâ€™t support range queries** (`$lt`, `$gt`, `$between`).

---

### **6ï¸âƒ£ Wildcard Index**

- **Indexes all fields dynamically**.
- **Example:** Index on all fields

```json
db.collection.createIndex({ "$**": 1 })
```

> âœ”ï¸ **Best for:** **Dynamic schemas** (when you donâ€™t know in advance which fields need to be indexed).

ğŸš¨ **Note:** **Wildcard indexes can use more storage** than specific indexes.

---

## âš™ï¸ **3ï¸âƒ£ How Indexing Works Internally in WiredTiger**

MongoDB uses **WiredTiger** as its default storage engine, which stores **indexes separately** from document data.

ğŸ“‚ **MongoDB File Structure:**

```in
/data/db/
  â”œâ”€â”€ collection-2.wt  # Data File (Stores Documents)
  â”œâ”€â”€ index-3.wt       # Index File (Stores Indexes)
  â”œâ”€â”€ WiredTigerLog.*  # Write-Ahead Log
```

ğŸ“Œ **Indexes are stored as B+ Trees inside `index-*.wt` files.**  
ğŸ“Œ **Data is stored in BSON format inside `collection-*.wt` files.**

### **ğŸ” How Indexes Store Data (B+ Tree Structure)**

```ini
        [Root Node]
            |
    ------------------
    |       |       |
  Ahmed   Hady    Mohamed
    â†“        â†“         â†“
[Doc1]   [Doc2]   [Doc3]
```

> âœ”ï¸ **Index nodes store field values and pointers to documents in the Data Pages.**

---

## ğŸ“Š **4ï¸âƒ£ Indexing Performance Trade-offs & Best Practices**

| **Best Practice**                             | **Why?**                                      |
| --------------------------------------------- | --------------------------------------------- |
| **Index frequently searched fields**          | Speeds up query performance.                  |
| **Use Compound Indexes for multiple filters** | Avoids multiple index scans.                  |
| **Donâ€™t index every field**                   | Indexes consume extra storage & slow inserts. |
| **Use Covered Queries**                       | Reduces need to fetch documents.              |
| **Use Hashed Indexes for Sharding**           | Distributes data evenly across shards.        |

ğŸš¨ **Too many indexes slow down writes!** **Each insert must update all indexes.**

---

## ğŸ–¼ï¸ **5ï¸âƒ£ Sequence Diagram: How Index-Based Queries Work**

```mermaid
sequenceDiagram
    participant User as User
    participant QueryEngine as MongoDB Query Engine
    participant WiredTiger as WiredTiger Storage Engine
    participant Disk as Disk Storage

    User->>QueryEngine: db.users.findOne({ "email": "ahmed@example.com" })
    QueryEngine->>WiredTiger: Check if index exists on `email`
    alt Index Exists?
        WiredTiger->>Disk: Fetch Index Page from `index-3.wt`
        Disk-->>WiredTiger: Return Index B+ Tree Nodes
        WiredTiger->>QueryEngine: Find document pointer for "Ahmed"
        QueryEngine->>WiredTiger: Fetch Data Page from `collection-2.wt`
        WiredTiger->>Disk: Read BSON Document
        Disk-->>WiredTiger: Return BSON Document
    else No Index (Collection Scan)
        WiredTiger->>Disk: Read entire `collection-2.wt` page by page
        Disk-->>WiredTiger: Load all documents into memory
        WiredTiger->>QueryEngine: Scan each document for `email="ahmed@example.com"`
    end
    QueryEngine-->>User: Return JSON Document
```

ğŸ“Œ **Key Takeaways from the Diagram**  
âœ” **Indexes allow MongoDB to quickly locate documents, avoiding full collection scans.**  
âœ” **Without an index, MongoDB must scan every document, making queries slow.**

---

## ğŸ **Final Takeaways**

ğŸ”¥ **Indexes are essential for performance in DocumentDB (MongoDB).**  
ğŸ”¥ **Use Compound & Covered Indexes for complex queries.**  
ğŸ”¥ **Avoid excessive indexing, as it impacts write performance.**  
ğŸ”¥ **Hashed Indexes help with sharding, but donâ€™t support range queries.**  
ğŸ”¥ **WiredTiger stores indexes separately in `.wt` files for fast lookups.**

ğŸ’¡ **Next Topic?** Want a deep dive into **how Write-Ahead Logging (WAL) and journaling work in WiredTiger? ğŸš€ğŸ”¥**
