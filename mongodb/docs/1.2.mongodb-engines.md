# **ğŸ” MongoDB Internals â€“ Storage Engine Evolution (MMAPv1 vs. WiredTiger) Simplified ğŸš€**

MongoDB has evolved significantly in how it **stores and retrieves data**. It started with **MMAPv1**, which had major limitations, and later moved to **WiredTiger**, which is now the default storage engine.

This guide will **explain the evolution of MongoDB storage engines in detail, using simple terms and diagrams** so you can fully understand how **documents are stored, retrieved, and indexed**.

---

## **ğŸ› ï¸ 1ï¸âƒ£ What is a Storage Engine?**

A **storage engine** is the **core part of the database** that decides **how data is written to and read from the disk**. Every database (MySQL, PostgreSQL, MongoDB) has a **storage engine** that handles:

âœ”ï¸ **How data is structured on disk (tables, indexes, documents, etc.)**  
âœ”ï¸ **How queries are processed efficiently**  
âœ”ï¸ **How updates and deletes modify data on disk**  
âœ”ï¸ **How multiple users can read/write at the same time without conflicts**

---

## **ğŸ’¾ 2ï¸âƒ£ MMAPv1 â€“ The First MongoDB Storage Engine (Pre-3.2)**

**MMAPv1 (Memory-Mapped Files)** was MongoDBâ€™s **original storage engine**, but it had several issues:

âœ”ï¸ It used **memory-mapped files**, meaning it relied on the **operating system (OS) to read/write data**.  
âœ”ï¸ Documents were stored **directly on disk in BSON format (uncompressed)**.  
âœ”ï¸ Every document had a **DiskLoc** (file + offset) that pointed to where the document was stored on disk.  
âœ”ï¸ If a document was updated and got **bigger**, it had to be **moved to a new location**, causing fragmentation.  
âœ”ï¸ **Writes were slow** because MongoDB **locked the entire database** when updating.

---

### **ğŸ’¡ How MMAPv1 Stored Data**

MMAPv1 stored **every document at a specific location on disk**, identified by a **DiskLoc**.

#### **ğŸ“Œ What is DiskLoc?**

DiskLoc is a **pair of numbers** that tells MongoDB **where a document is stored on disk**.

| **DiskLoc Structure** | **Meaning**                                                              |
| --------------------- | ------------------------------------------------------------------------ |
| **File Number** ğŸ—‚ï¸    | Identifies which data file the document is in (e.g., `collection-2.wt`). |
| **Offset** ğŸ“         | The exact **position (byte offset)** of the document inside the file.    |

ğŸ’¡ **Think of DiskLoc like a book reference:**

- **File Number** = Which book ğŸ“š
- **Offset** = Page & line number ğŸ“–

Example:

```json
DiskLoc: { file: 3, offset: 45678 }
```

- This means the document is **stored inside file number 3**, starting at **byte 45,678**.

---

### **ğŸ” How MMAPv1 Executed Queries**

When a user runs:

```json
db.users.findOne({ "email": "ahmed@example.com" })
```

MongoDB follows these steps:

```mermaid
sequenceDiagram
    participant User as User
    participant QueryEngine as MongoDB Query Engine
    participant MMAPv1 as MMAPv1 Storage Engine
    participant Disk as Disk Storage

    User->>QueryEngine: Find document with email="ahmed@example.com"
    QueryEngine->>MMAPv1: Check if an index exists
    alt Index Exists?
        MMAPv1->>Disk: Fetch index entry (B+ Tree)
        Disk-->>MMAPv1: Return DiskLoc (File + Offset)
        MMAPv1->>Disk: Fetch document from DiskLoc
        Disk-->>MMAPv1: Return BSON Document
    else No Index
        MMAPv1->>Disk: Scan entire collection file
        Disk-->>MMAPv1: Return matching document
    end
    MMAPv1->>QueryEngine: Return BSON document
    QueryEngine-->>User: Convert BSON to JSON & Return
```

ğŸ’¡ **Problems with MMAPv1:**  
âŒ **Fragmentation** â€“ If documents grow, they need to be moved, breaking DiskLoc.  
âŒ **Single Global Lock** â€“ Only **one write operation** could happen at a time.  
âŒ **No Compression** â€“ All documents were stored **uncompressed**, wasting disk space.

ğŸ”´ **Solution:** **MongoDB replaced MMAPv1 with WiredTiger in version 3.2**.

---

## **âš™ï¸ 3ï¸âƒ£ WiredTiger â€“ MongoDBâ€™s Default Storage Engine (3.2+)**

**In MongoDB 3.2, WiredTiger replaced MMAPv1** to improve:

âœ”ï¸ **Performance** â€“ Uses **document-level locking** (multiple users can write at the same time).  
âœ”ï¸ **Storage Efficiency** â€“ Compresses documents (Snappy/Zlib).  
âœ”ï¸ **Index Optimization** â€“ Uses **B+ Trees** instead of DiskLoc.

ğŸ’¡ **Major Change:**

- **No more DiskLoc** (file + offset).
- Instead, MongoDB assigns each document a **RecordId (a unique 64-bit integer).**

---

### **ğŸ’¡ What is RecordId?**

A **RecordId** is a **64-bit integer** (instead of DiskLoc) that uniquely identifies a document.

ğŸ’¡ **Why is RecordId better than DiskLoc?**
âœ”ï¸ **Doesnâ€™t break when documents grow** (unlike DiskLoc).  
âœ”ï¸ **Allows WiredTiger to store data more efficiently**.  
âœ”ï¸ **Indexes now point to RecordId instead of file + offset.**

Example:

```json
RecordId: 1234567890
```

- This means the document **can be stored anywhere**, and MongoDB can still find it quickly.

---

### **ğŸ” How WiredTiger Executes Queries**

Now, when a user runs:

```json
db.users.findOne({ "email": "ahmed@example.com" })
```

MongoDB follows these steps:

```mermaid
sequenceDiagram
    participant User as User
    participant QueryEngine as MongoDB Query Engine
    participant WiredTiger as WiredTiger Storage Engine
    participant Disk as Disk Storage

    User->>QueryEngine: Find document with email="ahmed@example.com"
    QueryEngine->>WiredTiger: Check if an index exists
    alt Index Exists?
        WiredTiger->>Disk: Fetch Index Page from `index-3.wt`
        Disk-->>WiredTiger: Return RecordId
        WiredTiger->>QueryEngine: Find RecordId for "Ahmed"
        QueryEngine->>WiredTiger: Fetch Data Page from `collection-2.wt`
        WiredTiger->>Disk: Read BSON Document
        Disk-->>WiredTiger: Return BSON Document
    else No Index
        WiredTiger->>Disk: Read entire `collection-2.wt` page by page
        Disk-->>WiredTiger: Load all documents into memory
        WiredTiger->>QueryEngine: Scan each document for `email="ahmed@example.com"`
    end
    QueryEngine-->>User: Return JSON Document
```

ğŸ’¡ **Key Takeaways:**  
âœ”ï¸ **WiredTiger uses RecordId instead of DiskLoc for fast lookups.**  
âœ”ï¸ **Documents are stored compressed, reducing disk usage.**  
âœ”ï¸ **Index lookups are more efficient, making queries faster.**

---

## **ğŸ† 4ï¸âƒ£ MMAPv1 vs. WiredTiger â€“ Key Differences**

| Feature                | MMAPv1 (Old)                               | WiredTiger (New)                 |
| ---------------------- | ------------------------------------------ | -------------------------------- |
| **Document Storage**   | BSON (Uncompressed)                        | BSON (Compressed)                |
| **Primary Key Lookup** | `_id â†’ DiskLoc (File + Offset)`            | `_id â†’ RecordId (64-bit int)`    |
| **Writes**             | **Single Global Lock**                     | **Document-Level Locking**       |
| **Fragmentation**      | **Yes** (Documents move, breaking DiskLoc) | **No** (Documents stay in place) |
| **Compression**        | âŒ No                                      | âœ”ï¸ Yes (Snappy/Zlib)             |

âœ”ï¸ **WiredTiger is more efficient, faster, and scalable!**

---

## **ğŸ”¥ Next Topics:**

Now that weâ€™ve covered **MongoDB Storage Engines**, we can move to **how queries are executed internally in more depth**.

ğŸ›  **Next Topics:**  
âœ”ï¸ **How Queries Are Executed (Query Planner, Execution Plan, Index Selection)**  
âœ”ï¸ **How WiredTiger Handles Writes, Updates & Journaling**  
âœ”ï¸ **Sharding & Replication Internals**

ğŸ’¡ **Let me know if you want to continue! ğŸš€ğŸ”¥**
