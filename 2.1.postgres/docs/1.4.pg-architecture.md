# ğŸš€ **PostgreSQL Architecture - A Deep Dive into Internals**

PostgreSQL is a **multi-process database system** that efficiently manages client connections, transactions, logging, memory, and background maintenance.

---

## ğŸ¢ **Overview of PostgreSQL Architecture**

When a **client connects** (e.g., a web app or psql CLI), PostgreSQL handles it through several processes:

- **Postmaster Process**: The main process that manages database startup, authentication, and connection handling.
- **Backend Processes**: Separate processes assigned to each connected client to execute queries.
- **Shared Memory**: Where WAL (Write-Ahead Logging) and buffer pages reside.
- **Background Workers**: Perform additional tasks like indexing, parallel query execution, and logical replication.
- **Autovacuum Workers**: Maintain table health by clearing dead tuples.
- **WAL Senders & Receivers**: Ensure replication and streaming to standby servers.
- **Auxiliary Processes**: Responsible for tasks like logging, writing WAL files, and database recovery.

---

<div style="text-align: center;">
  <img src="images/postgres-architecture-1.png" alt="postgres-architecture" />
  <img src="images/postgres-architecture-2.png" alt="postgres-architecture" />
</div>

---

## ğŸ”„ **PostgreSQL Processes vs Threads**

Unlike databases that use **thread-based** architectures (e.g., MySQL), PostgreSQL is **process-based**. Each client connection spawns a **separate process**, avoiding shared memory corruption but consuming more resources.

âœ… **Why use processes over threads?**

- **Isolation**: If one process crashes, it doesn't affect others.
- **Security**: Process-based architecture avoids shared memory corruption.
- **Performance tradeoff**: While process-based systems are more robust, they consume more memory compared to thread-based databases.

---

## ğŸ  **1. Postmaster Process (Parent Process)**

### ğŸ”¹ **What is the Postmaster Process?**

The **Postmaster Process** is the **main entry point** for PostgreSQL. It is responsible for:

- Handles new client connections.
- Restarts crashed backend processes.
- Manages shared memory allocation.
- Managing **backend processes** (user connections).

### ğŸ”„ **How the Postmaster Works?**

- **1ï¸âƒ£** The Postmaster listens on **port 5432** for new TCP connections.
- **2ï¸âƒ£** When a new connection arrives, it:
  - **Authenticates the user** (password, certificates, Kerberos, etc.).
  - **Spawns a new Backend Process** (`postgres`).
- Passes the connection to the newly created process.

- **3ï¸âƒ£** **If too many connections** occur, it **queues** them or rejects based on `max_connections`.

ğŸ”¹ **Tuning Connection Handling:**

```ini
max_connections = 200  # Max allowed concurrent connections
superuser_reserved_connections = 5  # Reserved slots for superuser
```

> ğŸš€ Optimization: Use connection pooling (e.g., PgBouncer) instead of opening too many backend processes.

---

## ğŸ‘¤ **2. Backend Processes (User Connections)**

### ğŸ”¹ **What are Backend Processes?**

- When a **client (application, psql, or web server)** connects to PostgreSQL, the Postmaster creates a **separate backend process** for each connection.

- **Backend processes run independently** and **stay alive** as long as the user is connected.

### ğŸ”„ **Backend Process Workflow**

- **1ï¸âƒ£** The Postmaster accepts a new **client connection**.
- **2ï¸âƒ£** It **forks a new backend process** (`postgres`) to handle the clientâ€™s queries.
- **3ï¸âƒ£** The backend process:
  - Parses and **executes SQL queries**.
  - Maintains **transaction state**.
  - Reads/modifies data in **Shared Buffers**.
  - **Writes WAL logs** for durability.
- **4ï¸âƒ£** When the client disconnects, the backend process is **terminated**.

ğŸ”¹ **Backend processes interact heavily with:**

- **âœ… Shared Buffers** â†’ Caching data pages.
- **âœ… WAL Logs** â†’ Logging transaction changes.
- **âœ… Locks & Concurrency Control** â†’ Ensuring isolation levels.

---

## ğŸ”„ **3. Shared Memory (Caching, WAL, Locking)**

PostgreSQLâ€™s **Shared Memory** is where data pages and transaction logs are stored **temporarily in RAM**.

### ğŸ”„ **Components of Shared Memory**

| Component                       | Description                                                    |
| ------------------------------- | -------------------------------------------------------------- |
| **Shared Buffers**              | Caches frequently accessed database pages.                     |
| **WAL Buffers**                 | Temporary storage for Write-Ahead Logs before writing to disk. |
| **Lock Table**                  | Stores row-level and table-level locks.                        |
| **Statistics Collector Memory** | Stores query execution statistics.                             |

### ğŸ”„ **How PostgreSQL Uses Shared Memory?**

- **1ï¸âƒ£** When a query requests data, PostgreSQL **first checks Shared Buffers**.
- **2ï¸âƒ£** If the page **is present**, it is returned immediately.
- **3ï¸âƒ£** If **not present**, PostgreSQL **fetches the page from disk** and stores it in Shared Buffers.
- **4ï¸âƒ£** Modified pages are marked as **dirty pages** and later written to disk by the **Background Writer**.
- **5ï¸âƒ£** WAL logs are temporarily stored in **WAL Buffers** before being flushed to disk.

ğŸ”¹ **Key Parameters to Tune Shared Memory**

```ini
shared_buffers = 4GB  # In-memory cache for faster queries
wal_buffers = 16MB  # Buffer for write-ahead logs
work_mem = 64MB  # Memory allocated per query operation
```

### ğŸ“Š **Buffer Cache Hit Ratio in PostgreSQL**

#### ğŸ”¹ **What is Buffer Cache Hit Ratio?**

The **Buffer Cache Hit Ratio** measures how often queries retrieve data **from memory (shared buffers)** instead of disk. A **high ratio** means PostgreSQL is efficiently using RAM, reducing expensive disk I/O.

#### ğŸ”„ **Formula for Buffer Cache Hit Ratio**

```sql
SELECT
  SUM(blks_hit) / NULLIF(SUM(blks_hit) + SUM(blks_read), 0) AS buffer_cache_hit_ratio
FROM pg_stat_database;
```

âœ… **`blks_hit`** â†’ Number of times PostgreSQL found data in shared buffers.  
âœ… **`blks_read`** â†’ Number of times PostgreSQL had to fetch data from disk.  
âœ… **A ratio close to 1 (or 100%) is optimal.**

#### ğŸ“Œ **How to Interpret the Results?**

| Buffer Cache Hit Ratio | Performance Impact                                         |
| ---------------------- | ---------------------------------------------------------- |
| **> 90%**              | âœ… Excellent â€“ Most data is served from RAM.               |
| **70-90%**             | âš ï¸ Good â€“ Consider increasing `shared_buffers`.            |
| **< 70%**              | âŒ Poor â€“ Too many disk reads; optimize queries & indexes. |

#### ğŸ”§ **How to Improve Cache Hit Ratio?**

âœ… **Increase `shared_buffers`** to allocate more RAM for caching:

```ini
shared_buffers = 4GB  # 25-40% of system RAM recommended
```

âœ… **Optimize Queries & Index Usage** to reduce unnecessary disk reads.  
âœ… **Use Connection Pooling** (PgBouncer) to prevent excessive backend process churn.  
âœ… **Enable `pg_prewarm` Extension** to preload frequently accessed tables into memory.

---

## ğŸ› ï¸ **4. Background Workers (Parallel Processing)**

### ğŸ”¹ **What are Background Workers?**

- Background workers **handle non-client tasks** (**asynchronous tasks**) like **parallel queries, maintenance, and replication**.
- When a complex query runs, PostgreSQL can split it into smaller tasks using Parallel Query Workers.

### ğŸ”„ **Types of Background Workers**

| Worker                          | Function                                                             |
| ------------------------------- | -------------------------------------------------------------------- |
| **Parallel Query Workers**      | Used for **parallel execution** of queries.                          |
| **Logical Replication Workers** | Handles **logical replication** between databases.                   |
| **Extension Workers**           | Custom workers created by **extensions (Citus, TimescaleDB, etc.)**. |

ğŸ”¹ **Configured via:**

```ini
max_worker_processes = 8  # Maximum parallel workers
```

---

## âš™ï¸ **5. Auxiliary Processes (System Tasks)**

Auxiliary processes handle **essential tasks** like logging, WAL management, and startup recovery.

| Process                     | Role                                             |
| --------------------------- | ------------------------------------------------ |
| **Background Writer (bw)**  | Writes dirty pages from Shared Buffers to disk.  |
| **Checkpointer (cp)**       | Triggers WAL checkpoints to persist data.        |
| **Logger (lg)**             | Logs PostgreSQL activity.                        |
| **WAL Archiver (wa)**       | Archives old WAL files.                          |
| **WAL Writer (wr)**         | Flushes WAL logs to disk.                        |
| **Startup Process (st) ğŸš€** | Runs after a crash to recover lost transactions. |

ğŸ”¹ **Startup Process (Critical for Recovery):**

- **1ï¸âƒ£** Reads the last **checkpoint**.
- **2ï¸âƒ£** Applies **all uncommitted WAL records** to restore consistency.
- **3ï¸âƒ£** Ensures **data durability before allowing new connections**.

### ğŸš€ Optimizing Checkpoints

```ini
checkpoint_timeout = 5min  # Reduce frequency of full checkpoints
max_wal_size = 2GB  # Control how much WAL accumulates before a checkpoint
```

---

## ğŸ§¹ **6. Autovacuum Workers (Table Optimization)**

### ğŸ”¹ **Why is Autovacuum Needed?**

PostgreSQL **never overwrites old rows**. Instead, **it marks them as dead tuples**, Without cleaning, the database becomes **bloated**.

### ğŸ”„ **How Autovacuum Works?**

- **1ï¸âƒ£** The **Autovacuum Launcher (avl)** monitors detects tables with **dead tuples**.
- **2ï¸âƒ£** It spawns **Autovacuum Workers (av1, av2, â€¦)** reclaim space.
- **3ï¸âƒ£** The worker runs `VACUUM`, freeing up space for new data.

ğŸ”¹ **Configuration Example**

```ini
autovacuum = on  # Enable automatic cleanup
autovacuum_vacuum_threshold = 50  # Trigger vacuum if >50 dead tuples
autovacuum_vacuum_scale_factor = 0.2  # Vacuum when 20% of rows are dead
autovacuum_vacuum_cost_limit = 2000  # Control I/O impact
```

---

## ğŸ”„ **7. WAL Senders (Streaming Replication)**

### ğŸ”¹ **What are WAL Senders?**

WAL Senders (`ws1`, `ws2`) **stream WAL logs** to **replica servers** for **real-time replication**.

### ğŸ”„ **Streaming Replication Process**

- **1ï¸âƒ£** **WAL logs** are generated on the **primary database**.
- **2ï¸âƒ£** **WAL Senders** stream WAL logs to **standby servers**.
- **3ï¸âƒ£** Standby servers apply WAL logs, keeping them in **sync**.

ğŸ”¹ **Configured via:**

```ini
wal_level = replica  # Enable WAL for replication
max_wal_senders = 5  # Allow up to 5 replicas
synchronous_commit = on  # Ensure data is committed on standby
```
