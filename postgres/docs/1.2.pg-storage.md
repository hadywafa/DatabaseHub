# 📂 **How PostgreSQL Stores Data on the File System (Pages, Blocks, and Storage Layout)**

PostgreSQL stores data in **a structured file system format**, organizing tables and indexes into **blocks, pages, and segments**. Understanding this helps with **performance tuning, storage optimization, and troubleshooting**.

---

## 🔍 **1. Overview: PostgreSQL Storage System**

PostgreSQL follows a **multi-layered storage structure**, where:

- ✔️ Data is **stored in files** inside the **PostgreSQL data directory**.
- ✔️ Each **table and index** is broken into **1GB segment files** for efficiency.
- ✔️ Data is stored in **8KB pages** (blocks), which contain **rows (tuples)**.
- ✔️ PostgreSQL **never overwrites old rows** but marks them as **dead tuples** (handled by VACUUM).

---

## 📂 **2. Tablespaces, Data Files & Directory Structure**

### 🔹 **Default Storage Location**

By default, PostgreSQL stores all data in:  
📁 **`$PGDATA/base/`**

Each database inside PostgreSQL is stored as a **separate directory**, named by its **database OID**.

```bash
ls -lh /var/lib/postgresql/15/main/base/
```

📌 **Example Output:**

```ini
12345/  67890/  54321/
```

- `12345/` → Directory for one PostgreSQL database
- `67890/` → Directory for another database

### 🔹 **Tablespace Layout**

| Tablespace            | Directory Location                       |
| --------------------- | ---------------------------------------- |
| **pg_default**        | `$PGDATA/base/` (default storage)        |
| **pg_global**         | `$PGDATA/global/` (shared system tables) |
| **Custom Tablespace** | Stored in a user-specified directory     |

📌 **Query to List Tablespaces**

```sql
SELECT spcname, spclocation FROM pg_tablespace;
```

---

## 📏 **3. Storage Layout: Segments, Blocks, and Pages**

### 🔹 **Storage Hierarchy in PostgreSQL**

📂 **Database Directory** → 📄 **Relation Files (1GB Segments)** → 📦 **Blocks (8KB Pages)** → 🔹 **Tuples (Rows)**

### 🔄 **File Naming Format in PostgreSQL**

Each table or index consists of **multiple segment files** in this format:

```ini
<relfilenode>.1
<relfilenode>.2
```

📌 **Example: Table `users` with ID `16384`**

```bash
ls -lh /var/lib/postgresql/15/main/base/12345/
16384
16384.1
16384.2
16384_fsm
16384_vm
```

| File Type     | Description                             |
| ------------- | --------------------------------------- |
| **16384**     | First 1GB of the table                  |
| **16384.1**   | Second 1GB segment                      |
| **16384_fsm** | Free Space Map (tracks empty space)     |
| **16384_vm**  | Visibility Map (tracks vacuumed tuples) |

🔹 **Why 1GB Segments?**  
PostgreSQL splits large tables into **1GB chunks** to avoid filesystem limitations.

---

## 📦 **4. Heap Tables: Page Format & Row Storage**

Each **table and index** in PostgreSQL is stored as **8KB pages** (also called blocks).

### **🔄 PostgreSQL Heap Page Format**

📦 **A single 8KB page contains:**

```ini
| Page Header | Free Space | Row 1 | Row 2 | Row 3 | ...
```

| Section                             | Description                                                                 |
| ----------------------------------- | --------------------------------------------------------------------------- |
| **Page Header (24 bytes)**          | Stores metadata like checksums, LSN (Log Sequence Number), and tuple count. |
| **Row Pointers (Item Identifiers)** | Pointers to actual row locations within the page.                           |
| **Heap Tuples (Row Data)**          | The actual table data (rows).                                               |
| **Free Space**                      | Empty space for future row inserts.                                         |

### **🔄 How PostgreSQL Inserts a Row?**

- **1️⃣** The backend **fetches a page** from the table file.
- **2️⃣** If enough **free space** exists, the row is inserted.
- **3️⃣** If not, PostgreSQL **allocates a new page**.
- **4️⃣** The row’s **transaction status** is marked for visibility.

📌 **Checking Page-Level Information**

```sql
SELECT * FROM heap_page_items(get_raw_page('users', 0));
```

---

## 🏗️ **5. TOAST: Storing Large Values Efficiently**

**TOAST (The Oversized Attribute Storage Technique)** is PostgreSQL’s way of storing **large text, JSON, or bytea columns** efficiently.

### 🔹 **Why TOAST Exists?**

Since a **single page is 8KB**, PostgreSQL **cannot store large values** directly inside a row. Instead, it:  
✅ Moves large values **out of the main table** into a **TOAST table**.  
✅ Keeps only a **pointer** in the original row.

### **🔄 TOAST Storage Workflow**

- **1️⃣** A large text or JSON column **exceeds 8KB**.
- **2️⃣** PostgreSQL **moves the data to a separate TOAST table**.
- **3️⃣** The row now stores only a **reference (OID) to the TOAST table**.
- **4️⃣** When queried, PostgreSQL **fetches the large value from TOAST**.

📌 **Checking TOAST Tables**

```sql
SELECT relname, reltoastrelid FROM pg_class WHERE relname = 'users';
```

---

## 📑 **6. Indexes: How PostgreSQL Indexes Are Stored**

PostgreSQL supports different index types (**B-Tree, Hash, GiST, GIN, BRIN**), and each has its **own file format**.

### **🔹 B-Tree Index Storage**

✅ Stored in **8KB pages**.  
✅ Uses a **balanced tree** for fast lookups.  
✅ Leaf nodes store **pointers to table rows**.

📌 **Checking Index File Size**

```sql
SELECT pg_relation_size('users_index');
```

📌 **Viewing Index Structure**

```sql
EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM users WHERE email = 'test@example.com';
```

---

## 🛠 **7. Vacuum & Storage Maintenance**

### **🔹 Why Does PostgreSQL Need VACUUM?**

✅ **PostgreSQL never updates rows in place.**  
✅ Old rows remain **until VACUUM reclaims space**.  
✅ The **Visibility Map** helps track vacuumed pages.

📌 **Running Vacuum Manually**

```sql
VACUUM ANALYZE users;
```

📌 **Checking Dead Tuples**

```sql
SELECT relname, n_dead_tup FROM pg_stat_user_tables WHERE relname = 'users';
```

---

## 🎯 **Final Takeaways**

✔️ **PostgreSQL stores data in 8KB pages** for efficient access.  
✔️ **Tables and indexes split into 1GB segment files.**  
✔️ **TOAST stores large values separately to save space.**  
✔️ **Vacuum is necessary to reclaim space from dead tuples.**  
✔️ **Indexes are stored as B-Trees for fast lookups.**
