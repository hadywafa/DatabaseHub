# **ğŸ” MongoDB Internals â€“ How WiredTiger Handles Writes, Updates & Journaling ğŸš€**

Now that we've covered **how MongoDB executes queries**, let's dive into **how MongoDB handles writes, updates, and durability using WiredTiger**.

ğŸ’¡ **What happens when MongoDB inserts, updates, or deletes a document?**  
MongoDB **doesn't immediately write data to disk**â€”it uses techniques like **MVCC (Multi-Version Concurrency Control)** and **Write-Ahead Logging (WAL)** to optimize performance and ensure data durability.

---

## **ğŸ› ï¸ 1ï¸âƒ£ How MongoDB Handles Writes & Updates**

ğŸ’¡ **MongoDB writes are not immediately stored on disk**. Instead, they follow this process:

âœ”ï¸ **1. The client sends a write request.**  
âœ”ï¸ **2. MongoDB first writes the document to WiredTiger's in-memory cache.**  
âœ”ï¸ **3. The write is added to the Write-Ahead Log (WAL), also called a journal.**  
âœ”ï¸ **4. Periodically, MongoDB flushes the WAL to disk (commit).**  
âœ”ï¸ **5. If a crash happens, MongoDB can recover the data using the WAL.**

---

**ğŸ’¡ Example Write Operation:**

```json
db.users.insertOne({ "name": "Ahmed", "email": "ahmed@example.com" })
```

> ğŸ’¡ **MongoDB doesn't write this immediately to disk.**  
> Instead, it **buffers the write in memory and logs it in the journal first**.

---

## **ğŸ”„ 2ï¸âƒ£ Multi-Version Concurrency Control (MVCC) & Journaling**

ğŸ’¡ **What is MVCC (Multi-Version Concurrency Control)?**  
MVCC allows **multiple clients to read and write at the same time** **without blocking each other**.

### **ğŸ’¡ How MVCC Works in MongoDB**

âœ”ï¸ **Each write creates a new version of a document in memory.**  
âœ”ï¸ **Readers see the "old" version while the write is in progress.**  
âœ”ï¸ **Once the write is committed, new readers see the updated version.**

---

## **ğŸ” 3ï¸âƒ£ Write-Ahead Logging (WAL) â€“ Ensuring Durability**

ğŸ’¡ **MongoDB uses WAL (Write-Ahead Logging) to prevent data loss.**  
Instead of **immediately updating files on disk**, MongoDB **first writes changes to a journal log.**

### **ğŸ’¡ Why Use WAL?**

âœ”ï¸ **Faster Writes** â€“ Writing to a log file is faster than modifying data files directly.  
âœ”ï¸ **Crash Recovery** â€“ If MongoDB crashes, it can **replay the journal log** to recover lost writes.  
âœ”ï¸ **Atomicity** â€“ Ensures **all or nothing** updates (transactions).

### **ğŸ’¡ WAL Process in MongoDB**

**1ï¸âƒ£ Write operation is received.**  
**2ï¸âƒ£ Data is stored in memory.**  
**3ï¸âƒ£ The write is added to the WAL (journal).**  
**4ï¸âƒ£ After a few seconds, MongoDB flushes WAL changes to the main database file.**

---

## **ğŸ¯ 4ï¸âƒ£ Sequence Diagram: Write Operation in MongoDB**

```mermaid
sequenceDiagram
    participant User as User
    participant QueryEngine as MongoDB Query Engine
    participant WiredTiger as WiredTiger Storage Engine
    participant Journal as Write-Ahead Log (WAL)
    participant Disk as Disk Storage

    User->>QueryEngine: db.users.insertOne({ "name": "Ahmed" })
    QueryEngine->>WiredTiger: Store document in memory
    WiredTiger->>Journal: Append write operation to WAL
    Journal->>Disk: Flush WAL periodically
    WiredTiger->>Disk: Flush document changes to collection file (`collection-2.wt`)
    Disk-->>WiredTiger: Confirm write completed
    WiredTiger-->>QueryEngine: Return success message
    QueryEngine-->>User: Acknowledgment of insert
```

ğŸ’¡ **Key Takeaways from the Diagram:**  
âœ”ï¸ **Writes are first stored in memory.**  
âœ”ï¸ **Changes are logged in the WAL (journal) before being written to disk.**  
âœ”ï¸ **MongoDB periodically commits WAL changes to the database file.**

---

## **ğŸ† 5ï¸âƒ£ Summary â€“ How MongoDB Handles Writes & Updates**

âœ”ï¸ **MongoDB buffers writes in memory before writing to disk.**  
âœ”ï¸ **MVCC allows multiple reads/writes without conflicts.**  
âœ”ï¸ **Writes are logged in the WAL before being committed.**  
âœ”ï¸ **Journal logs help recover data in case of crashes.**  
âœ”ï¸ **Flushing writes in batches improves performance.**
